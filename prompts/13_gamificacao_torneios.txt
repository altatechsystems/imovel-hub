VocÃª Ã© um engenheiro full-stack sÃªnior responsÃ¡vel por implementar o sistema de **Co-Corretagem Gamificada com Ranking PÃºblico** (MVP+2).

IMPORTANTE:
Este prompt implementa um dos 4 serviÃ§os inovadores conforme especificado em:
- SERVICOS_INOVADORES.md (ServiÃ§o #1)
- PLANO_DE_NEGOCIOS.md Â§16.5
- AI_DEV_DIRECTIVE.md

Este recurso Ã© OPCIONAL e pode ser ativado em MVP+2.

========================
CONTEXTO DE NEGÃ“CIO
========================

**Oportunidade de Mercado:**
- Construtoras lanÃ§am empreendimentos com 100-500 unidades
- Vendas tradicionais: 6-12 meses para vender 200 unidades
- Dor: Equipe de vendas limitada, alcance restrito

**SoluÃ§Ã£o:**
Transformar vendas em **competiÃ§Ã£o gamificada** entre corretores:
- Ranking pÃºblico em tempo real
- PremiaÃ§Ãµes automÃ¡ticas (top 1, top 3, top 10)
- Badges de performance (Ouro, Prata, Bronze)
- ViralizaÃ§Ã£o (500+ corretores promovendo o mesmo projeto)

**Resultado Esperado:**
- 200 unidades vendidas em 45-60 dias (vs 6 meses)
- 10x mais corretores ativos (50 â†’ 500)
- Engajamento viral (corretores competem publicamente)

**Receita Estimada (SERVICOS_INOVADORES.md):**
- Taxa de ativaÃ§Ã£o: R$ 5k por torneio
- 10 torneios/ano = R$ 50k
- Upsell mensal: R$ 3k/mÃªs/empreendimento ativo
- 15 empreendimentos ativos = R$ 45k/mÃªs = R$ 540k/ano
- **Total**: R$ 590k/ano
- **ROI**: 25x

========================
STACK TÃ‰CNICA
========================
Backend:
- Go (Golang) 1.21+ + Gin framework
- Google Cloud Firestore
- Firebase Authentication
- Cloud Scheduler (jobs automÃ¡ticos)

Frontend Admin (Dashboard Construtora):
- Next.js 14 (App Router)
- React Query + Zustand
- shadcn/ui + Tailwind CSS
- React Hook Form + Zod
- Recharts (grÃ¡ficos)

Frontend PÃºblico (Leaderboard):
- Next.js 14 (SSR para SEO)
- WebSockets ou Server-Sent Events (SSE) para ranking em tempo real
- Vercel Edge Functions

========================
OBJETIVO DESTE PROMPT
========================
Implementar sistema completo de torneios gamificados:

1. **Backend (Go):**
   - CRUD de torneios (Tournament)
   - Sistema de pontuaÃ§Ã£o e ranking
   - AtualizaÃ§Ãµes automÃ¡ticas (quando unidade Ã© vendida)
   - Jobs automÃ¡ticos (finalizar torneio, calcular vencedores)

2. **Frontend Admin:**
   - Dashboard de torneios
   - Criar/editar torneio
   - Visualizar ranking em tempo real
   - Configurar prÃªmios e regras

3. **Frontend PÃºblico:**
   - Leaderboard pÃºblico (ranking ao vivo)
   - Perfil do corretor (vendas, badges)
   - HistÃ³rico de torneios

4. **NotificaÃ§Ãµes:**
   - Email quando corretor sobe no ranking
   - Push notification quando novo torneio comeÃ§a
   - Alerta quando torneio estÃ¡ acabando

========================
MODELOS DE DADOS
========================

### Tournament (Torneio)

ColeÃ§Ã£o: `/tenants/{tenantId}/tournaments/{tournamentId}`

```go
package models

import "time"

type Tournament struct {
    ID          string    `firestore:"-" json:"id"`
    TenantID    string    `firestore:"tenant_id" json:"tenant_id"` // Construtora

    // VinculaÃ§Ã£o ao empreendimento
    DevelopmentID string `firestore:"development_id" json:"development_id"` // ref Development

    // InformaÃ§Ãµes bÃ¡sicas
    Name        string    `firestore:"name" json:"name"`         // "Torneio de LanÃ§amento Vista Verde"
    Description string    `firestore:"description" json:"description"`
    Slug        string    `firestore:"slug" json:"slug"`         // URL-friendly

    // PerÃ­odo
    StartDate   time.Time `firestore:"start_date" json:"start_date"`
    EndDate     time.Time `firestore:"end_date" json:"end_date"`
    IsActive    bool      `firestore:"is_active" json:"is_active"`

    // Status
    Status      TournamentStatus `firestore:"status" json:"status"` // draft, active, ended, cancelled

    // Regras e premiaÃ§Ãµes
    Rules       []TournamentRule  `firestore:"rules" json:"rules"`
    Prizes      []TournamentPrize `firestore:"prizes" json:"prizes"`

    // MÃ©tricas
    TotalParticipants int     `firestore:"total_participants" json:"total_participants"` // Corretores participantes
    TotalUnitsSold    int     `firestore:"total_units_sold" json:"total_units_sold"`     // Unidades vendidas no torneio
    TotalRevenue      float64 `firestore:"total_revenue" json:"total_revenue"`           // Receita total gerada

    // Visibilidade
    IsPublic    bool   `firestore:"is_public" json:"is_public"`         // Ranking pÃºblico?
    LeaderboardURL string `firestore:"leaderboard_url,omitempty" json:"leaderboard_url,omitempty"` // URL pÃºblica

    // Metadata
    CreatedBy string    `firestore:"created_by" json:"created_by"` // BrokerID (admin)
    CreatedAt time.Time `firestore:"created_at" json:"created_at"`
    UpdatedAt time.Time `firestore:"updated_at" json:"updated_at"`
}

type TournamentStatus string
const (
    TournamentStatusDraft     TournamentStatus = "draft"     // Rascunho (nÃ£o iniciado)
    TournamentStatusActive    TournamentStatus = "active"    // Ativo (em andamento)
    TournamentStatusEnded     TournamentStatus = "ended"     // Finalizado
    TournamentStatusCancelled TournamentStatus = "cancelled" // Cancelado
)

type TournamentRule struct {
    Type        string `firestore:"type" json:"type"`               // "points_per_unit", "bonus_first_week", "penalty_cancel"
    Description string `firestore:"description" json:"description"` // DescriÃ§Ã£o legÃ­vel
    Value       int    `firestore:"value" json:"value"`             // Valor numÃ©rico (pontos, %, etc)
}

type TournamentPrize struct {
    Rank        int    `firestore:"rank" json:"rank"`               // 1, 2, 3, etc
    Description string `firestore:"description" json:"description"` // "R$ 10.000 em dinheiro"
    Type        string `firestore:"type" json:"type"`               // "cash", "bonus_commission", "trip", "prize"
    Value       float64 `firestore:"value,omitempty" json:"value,omitempty"` // Valor monetÃ¡rio (se aplicÃ¡vel)
}
```

---

### TournamentParticipant (Participante do Torneio)

SubcoleÃ§Ã£o: `/tenants/{tenantId}/tournaments/{tournamentId}/participants/{participantId}`

```go
type TournamentParticipant struct {
    ID           string    `firestore:"-" json:"id"`
    TournamentID string    `firestore:"tournament_id" json:"tournament_id"` // ref Tournament
    TenantID     string    `firestore:"tenant_id" json:"tenant_id"`
    BrokerID     string    `firestore:"broker_id" json:"broker_id"`         // ref Broker

    // InformaÃ§Ãµes do corretor (denormalizado para performance)
    BrokerName   string `firestore:"broker_name" json:"broker_name"`
    BrokerCRECI  string `firestore:"broker_creci" json:"broker_creci"`
    BrokerAvatar string `firestore:"broker_avatar,omitempty" json:"broker_avatar,omitempty"` // URL

    // MÃ©tricas de performance
    UnitsSold       int     `firestore:"units_sold" json:"units_sold"`             // Unidades vendidas
    TotalCommission float64 `firestore:"total_commission" json:"total_commission"` // ComissÃ£o acumulada
    Points          int     `firestore:"points" json:"points"`                     // Pontos (se houver sistema de pontos)

    // Ranking
    CurrentRank     int       `firestore:"current_rank" json:"current_rank"`         // PosiÃ§Ã£o atual
    PreviousRank    int       `firestore:"previous_rank" json:"previous_rank"`       // PosiÃ§Ã£o anterior
    RankChange      int       `firestore:"rank_change" json:"rank_change"`           // VariaÃ§Ã£o (+5, -2, 0)
    LastRankUpdate  time.Time `firestore:"last_rank_update" json:"last_rank_update"` // Ãšltima atualizaÃ§Ã£o

    // Badges e conquistas
    Badges          []string  `firestore:"badges,omitempty" json:"badges,omitempty"` // ["gold", "first_sale", "speed_seller"]

    // PrÃªmios conquistados
    PrizesWon       []TournamentPrize `firestore:"prizes_won,omitempty" json:"prizes_won,omitempty"`

    // Status
    IsActive        bool      `firestore:"is_active" json:"is_active"` // Participante ativo?
    JoinedAt        time.Time `firestore:"joined_at" json:"joined_at"`
    LastSaleAt      *time.Time `firestore:"last_sale_at,omitempty" json:"last_sale_at,omitempty"` // Ãšltima venda
}
```

---

### TournamentSale (Venda no Torneio)

SubcoleÃ§Ã£o: `/tenants/{tenantId}/tournaments/{tournamentId}/sales/{saleId}`

**IMPORTANTE**: Esta collection Ã© um **espelho auditÃ¡vel** das vendas.
As vendas reais sÃ£o registradas em Property.development_info.unit_status = "sold".

```go
type TournamentSale struct {
    ID           string    `firestore:"-" json:"id"`
    TournamentID string    `firestore:"tournament_id" json:"tournament_id"` // ref Tournament
    TenantID     string    `firestore:"tenant_id" json:"tenant_id"`

    // VinculaÃ§Ã£o
    PropertyID   string    `firestore:"property_id" json:"property_id"`     // ref Property (unidade vendida)
    BrokerID     string    `firestore:"broker_id" json:"broker_id"`         // ref Broker (vendedor)

    // Dados da venda (denormalizado)
    UnitNumber   string    `firestore:"unit_number" json:"unit_number"`     // "Apto 302"
    SalePrice    float64   `firestore:"sale_price" json:"sale_price"`       // R$ 350.000
    Commission   float64   `firestore:"commission" json:"commission"`       // R$ 10.500 (3%)

    // PontuaÃ§Ã£o
    PointsAwarded int      `firestore:"points_awarded" json:"points_awarded"` // Pontos ganhos nesta venda

    // Metadata
    SoldAt       time.Time `firestore:"sold_at" json:"sold_at"`
    CreatedAt    time.Time `firestore:"created_at" json:"created_at"`
}
```

---

### BadgeDefinition (DefiniÃ§Ãµes de Badges)

ColeÃ§Ã£o: `/badge_definitions/{badgeId}` (GLOBAL, nÃ£o por tenant)

```go
type BadgeDefinition struct {
    ID          string `firestore:"-" json:"id"`

    // IdentificaÃ§Ã£o
    Code        string `firestore:"code" json:"code"`         // "gold", "silver", "bronze", "first_sale", "speed_seller"
    Name        string `firestore:"name" json:"name"`         // "Medalha de Ouro"
    Description string `firestore:"description" json:"description"` // "Top 1 do torneio"

    // Visual
    IconURL     string `firestore:"icon_url" json:"icon_url"` // URL do Ã­cone
    Color       string `firestore:"color" json:"color"`       // "#FFD700" (dourado)

    // Regra de conquista
    Condition   string `firestore:"condition" json:"condition"` // "rank == 1", "units_sold >= 5", "first_sale_in_tournament"

    // Metadata
    CreatedAt   time.Time `firestore:"created_at" json:"created_at"`
}

// Badges prÃ©-definidos
const (
    BadgeGold         = "gold"          // Top 1
    BadgeSilver       = "silver"        // Top 2-3
    BadgeBronze       = "bronze"        // Top 4-10
    BadgeFirstSale    = "first_sale"    // Primeira venda do torneio
    BadgeSpeedSeller  = "speed_seller"  // 3+ vendas em 1 semana
    BadgeCloser       = "closer"        // 10+ vendas no torneio
    BadgeConsistency  = "consistency"   // Vendeu em todas as semanas do torneio
)
```

========================
LÃ“GICA DE NEGÃ“CIO
========================

### Fluxo de CriaÃ§Ã£o de Torneio

1. **Admin cria torneio** (Dashboard):
   - Seleciona empreendimento
   - Define perÃ­odo (data inÃ­cio, data fim)
   - Configura prÃªmios (top 1, top 3, top 10)
   - Define regras (ex: 100 pontos por unidade vendida)
   - Publica torneio

2. **Sistema inicializa torneio** (Cloud Scheduler job):
   - Quando `start_date` chega:
     - Atualizar `status` = "active"
     - Criar `TournamentParticipant` vazio para todos os corretores vinculados ao empreendimento
     - Enviar notificaÃ§Ã£o: "Torneio comeÃ§ou!"

3. **Corretor vende unidade**:
   - Atualizar `Property.development_info.unit_status` = "sold"
   - **Trigger**: Se Property pertence a empreendimento com torneio ativo:
     - Criar `TournamentSale`
     - Incrementar `TournamentParticipant.units_sold`
     - Incrementar `TournamentParticipant.total_commission`
     - Calcular pontos (se sistema de pontos ativo)
     - **Recalcular ranking** (ver seÃ§Ã£o abaixo)
     - Enviar notificaÃ§Ã£o: "VocÃª vendeu 1 unidade! Subiu para 5Âº lugar"

4. **Sistema recalcula ranking** (tempo real ou batch a cada 5min):
   - Ordenar participantes por `units_sold DESC, last_sale_at ASC`
   - Atualizar `current_rank` de todos
   - Detectar mudanÃ§as (ex: BrokerA estava em 3Âº, agora estÃ¡ em 1Âº)
   - Atribuir badges (gold para rank 1, silver para rank 2-3, etc)
   - Enviar notificaÃ§Ãµes de mudanÃ§a de posiÃ§Ã£o

5. **Sistema finaliza torneio** (Cloud Scheduler job):
   - Quando `end_date` chega:
     - Atualizar `status` = "ended"
     - Calcular vencedores finais
     - Atribuir prÃªmios (`TournamentParticipant.prizes_won`)
     - Enviar notificaÃ§Ãµes: "Torneio encerrado! VocÃª ficou em 2Âº lugar e ganhou R$ 5.000"
     - Gerar relatÃ³rio final (PDF ou dashboard)

### Regra de Ranking

**CritÃ©rio de ordenaÃ§Ã£o**:
1. **PrimÃ¡rio**: `units_sold` (DESC) - Quem vendeu mais unidades
2. **Desempate 1**: `last_sale_at` (ASC) - Quem vendeu primeiro (em caso de empate)
3. **Desempate 2**: `joined_at` (ASC) - Quem entrou primeiro no torneio

**Exemplo**:
- Corretor A: 10 vendas, Ãºltima venda em 01/03
- Corretor B: 10 vendas, Ãºltima venda em 05/03
- Corretor C: 9 vendas, Ãºltima venda em 28/02
- **Ranking**: A (1Âº), B (2Âº), C (3Âº)

### Sistema de Pontos (Opcional)

Permite regras mais complexas alÃ©m de simples contagem de unidades:

**Exemplo de regras**:
- 100 pontos por unidade vendida
- +50 pontos se venda foi na primeira semana (bÃ´nus velocidade)
- +20 pontos se venda foi de tipologia premium (3 dorms)
- -30 pontos se venda foi cancelada

**CÃ¡lculo**:
```go
points := 100 // base
if soldAt.Sub(tournament.StartDate) <= 7*24*time.Hour {
    points += 50 // bÃ´nus primeira semana
}
if property.Bedrooms >= 3 {
    points += 20 // bÃ´nus premium
}
```

========================
ENDPOINTS BACKEND (GIN)
========================

### Tournaments

**POST /api/v1/tenants/:tenantId/tournaments**
- Criar torneio
- PermissÃ£o: admin da construtora
- Body: Tournament struct
- Behavior:
  - Gerar slug a partir do nome
  - Validar datas (start_date < end_date, start_date >= now)
  - Criar com status = "draft"
  - ActivityLog: tournament_created

**GET /api/v1/tenants/:tenantId/tournaments/:tournamentId**
- Buscar torneio por ID
- Incluir: Participantes (top 10), mÃ©tricas agregadas

**PATCH /api/v1/tenants/:tenantId/tournaments/:tournamentId**
- Atualizar torneio
- PermissÃ£o: admin da construtora
- Validar: NÃ£o pode alterar se status = "active" ou "ended"
- ActivityLog: tournament_updated

**POST /api/v1/tenants/:tenantId/tournaments/:tournamentId/publish**
- Publicar torneio (draft â†’ active)
- PermissÃ£o: admin da construtora
- Behavior:
  - Atualizar status = "active"
  - Criar participantes vazios para todos os corretores vinculados
  - Enviar notificaÃ§Ãµes
  - ActivityLog: tournament_published

**GET /api/v1/tenants/:tenantId/tournaments**
- Listar torneios do tenant
- Filtros: status, development_id
- Ordenar: start_date DESC

**GET /api/v1/tournaments/:slug/leaderboard** (PÃšBLICO)
- Buscar ranking pÃºblico do torneio
- Retornar: Top 100 participantes ordenados
- Cache: 5 minutos (Redis ou Vercel Edge Cache)

---

### Tournament Participants

**GET /api/v1/tenants/:tenantId/tournaments/:tournamentId/participants**
- Listar participantes do torneio
- Filtros: is_active, units_sold (min/max)
- Ordenar: current_rank ASC

**GET /api/v1/tenants/:tenantId/tournaments/:tournamentId/participants/:brokerID**
- Buscar participante especÃ­fico
- Retornar: MÃ©tricas, ranking, badges, histÃ³rico de vendas

**PATCH /api/v1/tenants/:tenantId/tournaments/:tournamentId/participants/:brokerID**
- Atualizar participante (admin apenas)
- Casos de uso: Desqualificar, ajustar pontos manualmente

---

### Tournament Sales

**POST /api/v1/tenants/:tenantId/tournaments/:tournamentId/sales** (INTERNAL)
- Registrar venda no torneio
- **IMPORTANTE**: Chamado automaticamente quando `Property.unit_status` = "sold"
- Behavior:
  - Criar TournamentSale
  - Incrementar TournamentParticipant.units_sold
  - Recalcular ranking
  - Enviar notificaÃ§Ã£o
  - ActivityLog: tournament_sale_registered

**GET /api/v1/tenants/:tenantId/tournaments/:tournamentId/sales**
- Listar vendas do torneio
- Filtros: broker_id, sold_at (range)
- Ordenar: sold_at DESC

---

### Ranking Recalculation (Background Job)

**POST /api/v1/internal/tournaments/:tournamentId/recalculate-ranking** (CRON)
- Recalcular ranking de todos os participantes
- Executado a cada 5 minutos (Cloud Scheduler)
- Behavior:
  1. Buscar todos os participantes do torneio
  2. Ordenar por units_sold DESC, last_sale_at ASC
  3. Atualizar current_rank, previous_rank, rank_change
  4. Atribuir badges (gold, silver, bronze)
  5. Enviar notificaÃ§Ãµes se houve mudanÃ§a de posiÃ§Ã£o
  6. ActivityLog: ranking_recalculated

========================
FRONTEND ADMIN (DASHBOARD)
========================

### PÃ¡ginas e Componentes

**1. /admin/tournaments** (Lista de Torneios)
- Tabela com torneios
- Colunas: Nome, Empreendimento, Status, PerÃ­odo, Participantes, Vendas, AÃ§Ãµes
- Filtros: Status, Empreendimento
- AÃ§Ã£o: Criar Novo Torneio

**2. /admin/tournaments/new** (Criar Torneio)
- Form multi-step:
  - Passo 1: InformaÃ§Ãµes BÃ¡sicas (nome, empreendimento, perÃ­odo)
  - Passo 2: Regras de PontuaÃ§Ã£o (pontos por venda, bÃ´nus, penalidades)
  - Passo 3: PrÃªmios (top 1, top 3, top 10)
  - Passo 4: Visibilidade (pÃºblico/privado, URL do leaderboard)
- ValidaÃ§Ã£o: React Hook Form + Zod
- AÃ§Ã£o: Salvar como Rascunho ou Publicar Imediatamente

**3. /admin/tournaments/:id** (Detalhes do Torneio)
- Tabs:
  - **Dashboard**: MÃ©tricas (vendas, participantes, grÃ¡fico de vendas por dia)
  - **Leaderboard**: Ranking completo com filtros
  - **Participantes**: Lista de corretores participantes
  - **Vendas**: HistÃ³rico de todas as vendas
  - **PrÃªmios**: ConfiguraÃ§Ã£o de prÃªmios e vencedores
  - **ConfiguraÃ§Ãµes**: Editar torneio (apenas se status = draft)

**4. /admin/tournaments/:id/leaderboard** (Ranking Detalhado)
- Tabela com participantes:
  - Colunas: Rank, Corretor, CRECI, Unidades Vendidas, ComissÃ£o, Pontos, Badges, Ãšltima Venda
  - Destaque: Top 3 com cards especiais (ouro, prata, bronze)
  - AtualizaÃ§Ã£o: Tempo real via SSE ou polling a cada 30s
- Exportar: CSV, PDF

**5. /admin/tournaments/:id/analytics** (AnalÃ­tica AvanÃ§ada)
- GrÃ¡ficos:
  - Vendas por dia (linha do tempo)
  - Vendas por corretor (bar chart)
  - DistribuiÃ§Ã£o de tipologias vendidas (pie chart)
  - Performance por semana (heatmap)
- MÃ©tricas:
  - Velocidade de vendas (unidades/dia)
  - Taxa de conversÃ£o (participantes ativos / total)
  - Ticket mÃ©dio

**Componentes ReutilizÃ¡veis:**

```typescript
// components/tournaments/TournamentCard.tsx
interface TournamentCardProps {
  tournament: Tournament;
  onEdit: (id: string) => void;
  onView: (id: string) => void;
}

// components/tournaments/LeaderboardTable.tsx
interface LeaderboardTableProps {
  participants: TournamentParticipant[];
  isRealTime?: boolean; // AtualizaÃ§Ã£o em tempo real
}

// components/tournaments/BadgeDisplay.tsx
interface BadgeDisplayProps {
  badges: string[]; // ["gold", "first_sale", "speed_seller"]
  size?: 'sm' | 'md' | 'lg';
}

// components/tournaments/PrizeConfig.tsx
interface PrizeConfigProps {
  prizes: TournamentPrize[];
  onChange: (prizes: TournamentPrize[]) => void;
}
```

========================
FRONTEND PÃšBLICO (LEADERBOARD)
========================

### PÃ¡gina PÃºblica de Ranking

**URL**: `/torneios/:slug/ranking`

**Layout**:
- Hero: Banner do empreendimento, nome do torneio, contagem regressiva
- Podium: Top 3 destacados (ouro, prata, bronze)
- Tabela: Top 100 participantes
- AtualizaÃ§Ã£o: Tempo real via SSE

**SEO**:
- Title: "[Nome do Torneio] - Ranking ao Vivo | [Empreendimento]"
- Meta Description: "Acompanhe o ranking ao vivo do torneio [Nome]. Veja quem estÃ¡ liderando!"
- JSON-LD: Event schema

**Componentes**:

```typescript
// app/torneios/[slug]/ranking/page.tsx
export default async function TournamentLeaderboardPage({ params }) {
  const tournament = await getTournamentBySlug(params.slug);
  const participants = await getLeaderboard(tournament.id);

  return (
    <>
      <TournamentHeader tournament={tournament} />
      <Podium topThree={participants.slice(0, 3)} />
      <LeaderboardTable participants={participants} />
      <LiveUpdates tournamentId={tournament.id} />
    </>
  );
}

// components/tournaments/public/Podium.tsx
interface PodiumProps {
  topThree: TournamentParticipant[];
}

// components/tournaments/public/LiveUpdates.tsx
// Usa EventSource (SSE) para atualizaÃ§Ã£o em tempo real
interface LiveUpdatesProps {
  tournamentId: string;
}
```

**Server-Sent Events (SSE) para Ranking em Tempo Real**:

```typescript
// app/api/tournaments/[id]/stream/route.ts
export async function GET(req: Request, { params }) {
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      // Poll Firestore a cada 30s
      const interval = setInterval(async () => {
        const participants = await getLeaderboard(params.id);
        const data = `data: ${JSON.stringify(participants)}\n\n`;
        controller.enqueue(encoder.encode(data));
      }, 30000);

      // Cleanup
      req.signal.addEventListener('abort', () => {
        clearInterval(interval);
        controller.close();
      });
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

========================
NOTIFICAÃ‡Ã•ES
========================

### Tipos de NotificaÃ§Ãµes

**1. Torneio Iniciado**
- Trigger: Tournament.status = "active"
- DestinatÃ¡rios: Todos os corretores vinculados ao empreendimento
- Canal: Email + Push notification (se app mÃ³vel)
- Template:
  ```
  ðŸ† Novo Torneio ComeÃ§ou!

  O torneio "[Nome]" acaba de comeÃ§ar!
  PerÃ­odo: [Data inÃ­cio] a [Data fim]
  PrÃªmio 1Âº lugar: [DescriÃ§Ã£o]

  [Ver Ranking] [Vender Agora]
  ```

**2. Nova Venda Registrada**
- Trigger: TournamentSale criado
- DestinatÃ¡rio: Corretor que vendeu
- Canal: Email + Push notification
- Template:
  ```
  ðŸŽ‰ ParabÃ©ns! VocÃª vendeu 1 unidade

  Unidade: [NÃºmero]
  ComissÃ£o: R$ [Valor]
  Sua posiÃ§Ã£o: [Rank]Âº lugar (subiu 3 posiÃ§Ãµes!)

  [Ver Ranking]
  ```

**3. MudanÃ§a de PosiÃ§Ã£o**
- Trigger: TournamentParticipant.rank_change != 0
- DestinatÃ¡rio: Corretor que mudou de posiÃ§Ã£o
- Canal: Push notification (tempo real)
- CondiÃ§Ãµes: Apenas se subiu >= 3 posiÃ§Ãµes OU entrou no top 10
- Template:
  ```
  ðŸ“ˆ VocÃª subiu no ranking!

  Nova posiÃ§Ã£o: 5Âº lugar (+3)
  Faltam 12 vendas para o 1Âº lugar

  [Ver Ranking]
  ```

**4. Torneio Acabando**
- Trigger: Tournament.end_date - now <= 24 horas
- DestinatÃ¡rios: Top 20 corretores
- Canal: Email + Push notification
- Template:
  ```
  â° Ãšltima Chance!

  O torneio "[Nome]" acaba em 24 horas!
  VocÃª estÃ¡ em [Rank]Âº lugar
  Faltam [N] vendas para o prÃªmio

  [Ver Ranking] [Vender Agora]
  ```

**5. Torneio Finalizado**
- Trigger: Tournament.status = "ended"
- DestinatÃ¡rios: Todos os participantes
- Canal: Email
- Template para vencedores:
  ```
  ðŸ† VocÃª Venceu!

  ParabÃ©ns! VocÃª ficou em [Rank]Âº lugar no torneio "[Nome]"

  Seu prÃªmio: [DescriÃ§Ã£o]
  Unidades vendidas: [N]
  ComissÃ£o total: R$ [Valor]

  [Ver Certificado] [Compartilhar]
  ```

========================
CLOUD SCHEDULER JOBS
========================

### Job 1: Iniciar Torneios

**Trigger**: A cada 1 hora
**FunÃ§Ã£o**: Verificar torneios com `status = "draft"` e `start_date <= now`

```go
func StartScheduledTournaments(ctx context.Context) error {
    now := time.Now()

    // Query: status = draft AND start_date <= now
    tournaments, err := repo.FindTournamentsToStart(ctx, now)
    if err != nil {
        return err
    }

    for _, tournament := range tournaments {
        // Atualizar status
        tournament.Status = TournamentStatusActive
        if err := repo.Update(ctx, tournament); err != nil {
            log.Printf("Erro ao ativar torneio %s: %v", tournament.ID, err)
            continue
        }

        // Criar participantes
        if err := createParticipants(ctx, tournament); err != nil {
            log.Printf("Erro ao criar participantes: %v", err)
            continue
        }

        // Enviar notificaÃ§Ãµes
        if err := notifyTournamentStarted(ctx, tournament); err != nil {
            log.Printf("Erro ao notificar: %v", err)
        }

        log.Printf("Torneio %s ativado com sucesso", tournament.ID)
    }

    return nil
}
```

**Cron**: `0 * * * *` (a cada hora)

---

### Job 2: Recalcular Rankings

**Trigger**: A cada 5 minutos
**FunÃ§Ã£o**: Recalcular ranking de todos os torneios ativos

```go
func RecalculateRankings(ctx context.Context) error {
    // Query: status = active
    tournaments, err := repo.FindActiveTournaments(ctx)
    if err != nil {
        return err
    }

    for _, tournament := range tournaments {
        if err := recalculateTournamentRanking(ctx, tournament.ID); err != nil {
            log.Printf("Erro ao recalcular ranking %s: %v", tournament.ID, err)
            continue
        }
    }

    return nil
}

func recalculateTournamentRanking(ctx context.Context, tournamentID string) error {
    // Buscar participantes
    participants, err := repo.FindParticipants(ctx, tournamentID)
    if err != nil {
        return err
    }

    // Ordenar: units_sold DESC, last_sale_at ASC
    sort.Slice(participants, func(i, j int) bool {
        if participants[i].UnitsSold != participants[j].UnitsSold {
            return participants[i].UnitsSold > participants[j].UnitsSold
        }
        if participants[i].LastSaleAt != nil && participants[j].LastSaleAt != nil {
            return participants[i].LastSaleAt.Before(*participants[j].LastSaleAt)
        }
        return participants[i].JoinedAt.Before(participants[j].JoinedAt)
    })

    // Atualizar ranks
    for i, p := range participants {
        newRank := i + 1
        if p.CurrentRank != newRank {
            p.PreviousRank = p.CurrentRank
            p.CurrentRank = newRank
            p.RankChange = p.PreviousRank - p.CurrentRank
            p.LastRankUpdate = time.Now()

            // Atribuir badges
            p.Badges = assignBadges(p, newRank)

            // Salvar
            if err := repo.UpdateParticipant(ctx, p); err != nil {
                return err
            }

            // Notificar se subiu >= 3 posiÃ§Ãµes ou entrou no top 10
            if p.RankChange >= 3 || (newRank <= 10 && p.PreviousRank > 10) {
                notifyRankChange(ctx, p)
            }
        }
    }

    return nil
}

func assignBadges(p TournamentParticipant, rank int) []string {
    badges := []string{}

    if rank == 1 {
        badges = append(badges, BadgeGold)
    } else if rank >= 2 && rank <= 3 {
        badges = append(badges, BadgeSilver)
    } else if rank >= 4 && rank <= 10 {
        badges = append(badges, BadgeBronze)
    }

    if p.UnitsSold >= 10 {
        badges = append(badges, BadgeCloser)
    }

    return badges
}
```

**Cron**: `*/5 * * * *` (a cada 5 minutos)

---

### Job 3: Finalizar Torneios

**Trigger**: A cada 1 hora
**FunÃ§Ã£o**: Finalizar torneios com `status = "active"` e `end_date <= now`

```go
func FinishScheduledTournaments(ctx context.Context) error {
    now := time.Now()

    // Query: status = active AND end_date <= now
    tournaments, err := repo.FindTournamentsToEnd(ctx, now)
    if err != nil {
        return err
    }

    for _, tournament := range tournaments {
        // Recalcular ranking final
        if err := recalculateTournamentRanking(ctx, tournament.ID); err != nil {
            log.Printf("Erro ao recalcular ranking final: %v", err)
        }

        // Atribuir prÃªmios
        if err := assignPrizes(ctx, tournament); err != nil {
            log.Printf("Erro ao atribuir prÃªmios: %v", err)
        }

        // Atualizar status
        tournament.Status = TournamentStatusEnded
        if err := repo.Update(ctx, tournament); err != nil {
            log.Printf("Erro ao finalizar torneio %s: %v", tournament.ID, err)
            continue
        }

        // Enviar notificaÃ§Ãµes
        if err := notifyTournamentEnded(ctx, tournament); err != nil {
            log.Printf("Erro ao notificar: %v", err)
        }

        log.Printf("Torneio %s finalizado com sucesso", tournament.ID)
    }

    return nil
}

func assignPrizes(ctx context.Context, tournament Tournament) error {
    participants, err := repo.FindTopParticipants(ctx, tournament.ID, 10)
    if err != nil {
        return err
    }

    for _, prize := range tournament.Prizes {
        if prize.Rank <= len(participants) {
            p := participants[prize.Rank-1]
            p.PrizesWon = append(p.PrizesWon, prize)
            if err := repo.UpdateParticipant(ctx, p); err != nil {
                return err
            }
        }
    }

    return nil
}
```

**Cron**: `0 * * * *` (a cada hora)

========================
INTEGRAÃ‡Ã•ES
========================

### IntegraÃ§Ã£o com Property (Unidades)

Quando uma unidade de empreendimento Ã© vendida, o sistema automaticamente:

1. **Detecta venda** (trigger em Property.unit_status):
```go
// internal/services/property_service.go

func (s *PropertyService) UpdateUnitStatus(ctx context.Context, propertyID string, newStatus UnitStatus) error {
    property, err := s.repo.GetByID(ctx, propertyID)
    if err != nil {
        return err
    }

    // Atualizar status
    property.DevelopmentInfo.UnitStatus = newStatus
    property.UpdatedAt = time.Now()

    if err := s.repo.Update(ctx, property); err != nil {
        return err
    }

    // âœ… SE STATUS = SOLD E EMPREENDIMENTO TEM TORNEIO ATIVO
    if newStatus == UnitStatusSold && property.DevelopmentInfo != nil {
        go s.handleTournamentSale(ctx, property)
    }

    return nil
}

func (s *PropertyService) handleTournamentSale(ctx context.Context, property Property) {
    // Buscar torneio ativo para este empreendimento
    tournament, err := s.tournamentRepo.FindActiveByDevelopment(ctx, property.DevelopmentInfo.DevelopmentID)
    if err != nil || tournament == nil {
        return // Sem torneio ativo
    }

    // Registrar venda no torneio
    sale := &TournamentSale{
        ID:           generateID(),
        TournamentID: tournament.ID,
        TenantID:     property.TenantID,
        PropertyID:   property.ID,
        BrokerID:     property.AssignedBrokerID, // Corretor que vendeu
        UnitNumber:   property.DevelopmentInfo.UnitNumber,
        SalePrice:    property.SalePrice,
        Commission:   property.SalePrice * 0.03, // 3%
        SoldAt:       time.Now(),
        CreatedAt:    time.Now(),
    }

    if err := s.tournamentRepo.CreateSale(ctx, sale); err != nil {
        log.Printf("Erro ao registrar venda no torneio: %v", err)
        return
    }

    // Atualizar participante
    participant, err := s.tournamentRepo.FindParticipant(ctx, tournament.ID, property.AssignedBrokerID)
    if err != nil {
        log.Printf("Erro ao buscar participante: %v", err)
        return
    }

    participant.UnitsSold++
    participant.TotalCommission += sale.Commission
    now := time.Now()
    participant.LastSaleAt = &now

    if err := s.tournamentRepo.UpdateParticipant(ctx, participant); err != nil {
        log.Printf("Erro ao atualizar participante: %v", err)
        return
    }

    // Enviar notificaÃ§Ã£o
    s.notificationService.NotifySaleRegistered(ctx, participant, sale)

    log.Printf("Venda registrada no torneio %s: %s vendeu %s", tournament.ID, participant.BrokerName, property.DevelopmentInfo.UnitNumber)
}
```

========================
CRITÃ‰RIOS DE SUCESSO
========================

âœ… Tournament CRUD completo no backend
âœ… TournamentParticipant tracking com ranking em tempo real
âœ… TournamentSale auditÃ¡vel vinculado a Property
âœ… Cloud Scheduler jobs (iniciar, recalcular, finalizar)
âœ… NotificaÃ§Ãµes (email + push) para eventos principais
âœ… Dashboard admin permite gestÃ£o completa de torneios
âœ… Leaderboard pÃºblico com SSE (tempo real)
âœ… Badges automÃ¡ticos (gold, silver, bronze, etc)
âœ… IntegraÃ§Ã£o com Property (vendas registram automaticamente)
âœ… GrÃ¡ficos de performance (vendas por dia, por corretor)
âœ… Export de ranking (CSV, PDF)
âœ… ActivityLog registra todos os eventos crÃ­ticos

========================
AUDITORIA OBRIGATÃ“RIA
========================

ActivityLog para eventos DESTE prompt:
- tournament_created
- tournament_updated
- tournament_published
- tournament_started (job automÃ¡tico)
- tournament_sale_registered
- ranking_recalculated (job automÃ¡tico)
- tournament_ended (job automÃ¡tico)
- prize_assigned
- badge_awarded
- notification_sent

Ver AI_DEV_DIRECTIVE.md seÃ§Ã£o 17 para campos obrigatÃ³rios.

========================
ENTREGA ESPERADA
========================

1. Backend Go:
   - Models: Tournament, TournamentParticipant, TournamentSale, BadgeDefinition
   - Repositories: TournamentRepository, ParticipantRepository
   - Services: TournamentService, RankingService, NotificationService
   - Handlers: TournamentHandler, LeaderboardHandler
   - Jobs: StartTournaments, RecalculateRankings, FinishTournaments

2. Frontend Admin:
   - PÃ¡ginas: Lista, Criar, Editar, Detalhes, Leaderboard, Analytics
   - Componentes: TournamentCard, LeaderboardTable, BadgeDisplay, PrizeConfig
   - Forms: ValidaÃ§Ã£o com Zod + React Hook Form
   - GrÃ¡ficos: Recharts (vendas, performance)

3. Frontend PÃºblico:
   - PÃ¡gina: /torneios/:slug/ranking (leaderboard pÃºblico)
   - SSE: Ranking em tempo real
   - SEO: JSON-LD Event schema

4. Cloud Scheduler:
   - 3 jobs configurados (iniciar, recalcular, finalizar)
   - Cron expressions corretas
   - Logs estruturados

5. NotificaÃ§Ãµes:
   - Email templates (SendGrid ou similar)
   - Push notifications (Firebase Cloud Messaging)
   - Webhooks para integraÃ§Ãµes externas

========================
NOTAS FINAIS
========================

- Este prompt pode ser executado APÃ“S o prompt 12 (lanÃ§amentos)
- Requer integraÃ§Ã£o com sistema de notificaÃ§Ãµes (email + push)
- Ranking recalculado a cada 5 minutos (ajustÃ¡vel conforme carga)
- Leaderboard pÃºblico usa cache de 5 minutos (CDN)
- SSE suporta atÃ© 10.000 conexÃµes simultÃ¢neas (Vercel Edge)
- Badges podem ser expandidos futuramente (100+ vendas, etc)
- PrÃªmios podem incluir NFTs no futuro (blockchain)

**ROI Esperado:**
- Taxa de ativaÃ§Ã£o: R$ 5k por torneio
- 10 torneios/ano = R$ 50k
- Upsell mensal: R$ 3k/mÃªs x 15 empreendimentos = R$ 540k/ano
- **Total**: R$ 590k/ano
- **Custo desenvolvimento**: R$ 20-25k (40-50h)
- **ROI**: 25x

**ReferÃªncias:**
- SERVICOS_INOVADORES.md (ServiÃ§o #1)
- PLANO_DE_NEGOCIOS.md Â§16.5
- prompts/12_lancamentos_construtoras.txt (Development model)
- prompts/01_foundation_mvp.txt (Property model)

---
name: nextjs-dev
description: Expert Next.js 14+ and React developer specializing in TypeScript, App Router, Server Components, shadcn/ui, React Query, and modern React patterns. Use when working with Next.js code, React components, TypeScript interfaces, client/server optimization, form handling, data fetching, state management, and UI component development.
---

# Next.js 14+ Development Skill

## Purpose

Assist with building modern, production-ready Next.js 14+ applications using TypeScript, App Router, Server Components, and the React ecosystem. Provide idiomatic React/Next.js code following best practices and leveraging the framework's built-in optimizations.

## Core Philosophy

Next.js applications should leverage the framework's strengths:
- Server Components by default for better performance
- Client Components only when necessary (interactivity, hooks, browser APIs)
- File-based routing with App Router
- Built-in optimizations (Image, Font, Script)
- Type safety with TypeScript throughout

## Project Context

This skill is optimized for a real estate marketplace platform with:
- **Public frontend** (PROMPT 04): Property listings, search, LGPD-compliant forms
- **Admin frontend** (PROMPT 04b): Property management, photo/video upload, drag-and-drop

### Technology Stack

- **Framework**: Next.js 14+ with App Router
- **Language**: TypeScript (strict mode)
- **UI Library**: shadcn/ui (Radix UI primitives + Tailwind)
- **Styling**: Tailwind CSS
- **Data Fetching**: React Query (client-side caching)
- **Validation**: Zod schemas
- **Drag & Drop**: @dnd-kit
- **Backend**: Go API (REST endpoints)

## Naming Conventions

### Files and Folders

```
app/
├── (public)/              # Route group (no URL segment)
│   ├── page.tsx          # Public homepage
│   └── imoveis/
│       └── [id]/
│           └── page.tsx  # Dynamic route: /imoveis/123
├── admin/
│   ├── layout.tsx        # Admin layout
│   └── imoveis/
│       ├── page.tsx      # /admin/imoveis
│       └── novo/
│           └── page.tsx  # /admin/imoveis/novo
└── api/
    └── revalidate/
        └── route.ts      # API route handler
```

### Component Files

- **Pages**: `page.tsx` (App Router convention)
- **Layouts**: `layout.tsx` (App Router convention)
- **Components**: `PascalCase.tsx` (e.g., `PropertyCard.tsx`, `PhotoGallery.tsx`)
- **Utilities**: `kebab-case.ts` (e.g., `format-price.ts`, `api-client.ts`)
- **Types**: `types.ts` or `types/index.ts`

### Component Naming

```typescript
// Component names: PascalCase
export function PropertyCard({ property }: PropertyCardProps) {}
export function PhotoVideoManager({ propertyId }: PhotoVideoManagerProps) {}

// Props interfaces: ComponentName + "Props"
interface PropertyCardProps {
  property: Property
}

// Hooks: use + PascalCase
function usePropertySearch(filters: SearchFilters) {}

// Utility functions: camelCase
function formatPrice(value: number): string {}
```

## TypeScript Best Practices

### Strict Type Safety

```typescript
// tsconfig.json should have:
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true
  }
}
```

### Interface vs Type

```typescript
// Prefer interfaces for object shapes (can be extended)
interface Property {
  id: string
  title: string
  price: number
}

// Use types for unions, intersections, mapped types
type Status = 'draft' | 'published' | 'archived'
type ReadonlyProperty = Readonly<Property>
```

### Zod Schemas for Validation

```typescript
import { z } from 'zod'

// Define schema
const propertySchema = z.object({
  title: z.string().min(10, 'Título deve ter no mínimo 10 caracteres'),
  price: z.number().positive('Preço deve ser positivo'),
  type: z.enum(['sale', 'rent']),
})

// Infer TypeScript type from schema
type PropertyFormData = z.infer<typeof propertySchema>

// Validate data
const result = propertySchema.safeParse(formData)
if (!result.success) {
  console.error(result.error.flatten())
}
```

## Server vs Client Components

### Server Components (Default)

Use for data fetching, static content, SEO:

```typescript
// app/imoveis/[id]/page.tsx
// No 'use client' directive = Server Component

interface PageProps {
  params: { id: string }
  searchParams: { [key: string]: string | string[] | undefined }
}

export default async function PropertyPage({ params }: PageProps) {
  // Fetch data directly (no useEffect needed)
  const property = await fetchProperty(params.id)

  return (
    <div>
      <h1>{property.title}</h1>
      <PropertyGallery photos={property.photos} />
    </div>
  )
}

// Generate metadata for SEO
export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
  const property = await fetchProperty(params.id)

  return {
    title: `${property.title} - Ecosistema Imob`,
    description: property.description,
    openGraph: {
      images: [property.photos[0]?.url],
    },
  }
}
```

### Client Components

Use ONLY when you need:
- Event handlers (`onClick`, `onChange`)
- React hooks (`useState`, `useEffect`, `useRef`)
- Browser APIs (`localStorage`, `window`)
- Third-party libraries that use hooks

```typescript
// components/PhotoVideoManager.tsx
'use client'

import { useState, useCallback } from 'react'
import { useDropzone } from 'react-dropzone'

interface PhotoVideoManagerProps {
  propertyId: string
  initialPhotos: Photo[]
}

export function PhotoVideoManager({ propertyId, initialPhotos }: PhotoVideoManagerProps) {
  const [photos, setPhotos] = useState(initialPhotos)

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    // Handle file upload
  }, [propertyId])

  const { getRootProps, getInputProps } = useDropzone({ onDrop })

  return (
    <div {...getRootProps()}>
      <input {...getInputProps()} />
      {/* UI */}
    </div>
  )
}
```

## Data Fetching Patterns

### Server Component Fetching

```typescript
// Direct async/await in Server Components
async function getProperties(tenantId: string): Promise<Property[]> {
  const response = await fetch(
    `${process.env.API_URL}/api/v1/tenants/${tenantId}/properties`,
    {
      next: { revalidate: 60 }, // Cache for 60 seconds
      headers: {
        'Authorization': `Bearer ${process.env.API_KEY}`,
      },
    }
  )

  if (!response.ok) {
    throw new Error('Failed to fetch properties')
  }

  return response.json()
}
```

### Client Component Fetching (React Query)

```typescript
'use client'

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

function useProperties(tenantId: string) {
  return useQuery({
    queryKey: ['properties', tenantId],
    queryFn: async () => {
      const response = await fetch(`/api/properties?tenantId=${tenantId}`)
      if (!response.ok) throw new Error('Failed to fetch')
      return response.json()
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}

function useUpdateProperty() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (property: Property) => {
      const response = await fetch(`/api/properties/${property.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(property),
      })
      if (!response.ok) throw new Error('Failed to update')
      return response.json()
    },
    onSuccess: (data) => {
      // Invalidate cache to refetch
      queryClient.invalidateQueries({ queryKey: ['properties'] })
    },
  })
}
```

## shadcn/ui Component Usage

### Installation Pattern

```bash
# Add components as needed
npx shadcn-ui@latest add button
npx shadcn-ui@latest add card
npx shadcn-ui@latest add dialog
```

### Component Composition

```typescript
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'

export function PropertyCard({ property }: PropertyCardProps) {
  return (
    <Card className="overflow-hidden hover:shadow-lg transition-shadow">
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          {property.title}
          <Badge variant={property.status === 'published' ? 'default' : 'secondary'}>
            {property.status}
          </Badge>
        </CardTitle>
      </CardHeader>
      <CardContent>
        <p className="text-2xl font-bold text-primary">
          {formatPrice(property.price)}
        </p>
        <Button className="w-full mt-4">Ver Detalhes</Button>
      </CardContent>
    </Card>
  )
}
```

### Form Handling with React Hook Form + Zod

```typescript
'use client'

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'

const formSchema = z.object({
  title: z.string().min(10),
  price: z.coerce.number().positive(),
})

type FormData = z.infer<typeof formSchema>

export function PropertyForm({ onSubmit }: PropertyFormProps) {
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: '',
      price: 0,
    },
  })

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Título</FormLabel>
              <FormControl>
                <Input placeholder="Casa com 3 quartos..." {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="price"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Preço (R$)</FormLabel>
              <FormControl>
                <Input type="number" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit">Salvar</Button>
      </form>
    </Form>
  )
}
```

## Drag and Drop with @dnd-kit

```typescript
'use client'

import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core'
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  rectSortingStrategy,
  useSortable,
} from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'

interface SortablePhotoProps {
  photo: Photo
}

function SortablePhoto({ photo }: SortablePhotoProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
  } = useSortable({ id: photo.id })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  }

  return (
    <div ref={setNodeRef} style={style} {...attributes} {...listeners}>
      <img src={photo.url} alt={photo.alt} className="w-full h-48 object-cover" />
    </div>
  )
}

export function PhotoGallery({ photos, onReorder }: PhotoGalleryProps) {
  const [items, setItems] = useState(photos)

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  )

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event

    if (over && active.id !== over.id) {
      setItems((items) => {
        const oldIndex = items.findIndex((i) => i.id === active.id)
        const newIndex = items.findIndex((i) => i.id === over.id)

        const newOrder = arrayMove(items, oldIndex, newIndex)
        onReorder(newOrder)
        return newOrder
      })
    }
  }

  return (
    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
      <SortableContext items={items} strategy={rectSortingStrategy}>
        <div className="grid grid-cols-3 gap-4">
          {items.map((photo) => (
            <SortablePhoto key={photo.id} photo={photo} />
          ))}
        </div>
      </SortableContext>
    </DndContext>
  )
}
```

## File Upload with react-dropzone

```typescript
'use client'

import { useCallback } from 'react'
import { useDropzone } from 'react-dropzone'
import { Upload } from 'lucide-react'

export function PhotoUpload({ onUpload }: PhotoUploadProps) {
  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    const formData = new FormData()
    acceptedFiles.forEach(file => formData.append('photos', file))

    try {
      const response = await fetch('/api/photos', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) throw new Error('Upload failed')

      const photos = await response.json()
      onUpload(photos)
    } catch (error) {
      console.error('Upload error:', error)
    }
  }, [onUpload])

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/jpeg': ['.jpg', '.jpeg'],
      'image/png': ['.png'],
      'image/webp': ['.webp'],
    },
    maxSize: 10 * 1024 * 1024, // 10MB
  })

  return (
    <div
      {...getRootProps()}
      className={`
        border-2 border-dashed rounded-lg p-8 text-center cursor-pointer
        transition-colors
        ${isDragActive ? 'border-primary bg-primary/5' : 'border-gray-300'}
      `}
    >
      <input {...getInputProps()} />
      <Upload className="mx-auto h-12 w-12 text-gray-400" />
      <p className="mt-2 text-sm text-gray-600">
        {isDragActive
          ? 'Solte as fotos aqui...'
          : 'Arraste fotos ou clique para selecionar'}
      </p>
      <p className="text-xs text-gray-500 mt-1">
        Máximo 10MB por foto (JPEG, PNG, WebP)
      </p>
    </div>
  )
}
```

## Environment Variables

```typescript
// .env.local (not committed)
NEXT_PUBLIC_API_URL=https://api.ecosistema-imob.com
API_URL=https://api.ecosistema-imob.com  # Server-side only
API_KEY=secret123  # Server-side only

// Usage in code
// Client components: NEXT_PUBLIC_ prefix
const apiUrl = process.env.NEXT_PUBLIC_API_URL

// Server components/API routes: any name
const apiKey = process.env.API_KEY
```

## Error Handling

### Server Components

```typescript
// app/imoveis/[id]/error.tsx
'use client'

interface ErrorProps {
  error: Error & { digest?: string }
  reset: () => void
}

export default function Error({ error, reset }: ErrorProps) {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h2 className="text-2xl font-bold">Algo deu errado!</h2>
      <p className="text-gray-600 mt-2">{error.message}</p>
      <Button onClick={reset} className="mt-4">
        Tentar novamente
      </Button>
    </div>
  )
}
```

### Client Components (React Query)

```typescript
const { data, error, isLoading, isError } = useQuery({
  queryKey: ['property', id],
  queryFn: fetchProperty,
})

if (isLoading) return <Skeleton />
if (isError) return <ErrorMessage error={error} />

return <PropertyDetails property={data} />
```

## Loading States

```typescript
// app/imoveis/[id]/loading.tsx
export default function Loading() {
  return (
    <div className="animate-pulse">
      <div className="h-8 bg-gray-200 rounded w-3/4 mb-4" />
      <div className="h-4 bg-gray-200 rounded w-1/2 mb-2" />
      <div className="h-4 bg-gray-200 rounded w-2/3" />
    </div>
  )
}
```

## Accessibility Best Practices

```typescript
// Semantic HTML
<nav aria-label="Navegação principal">
  <ul role="list">
    <li><a href="/">Início</a></li>
  </ul>
</nav>

// Form labels
<label htmlFor="title">Título do Imóvel</label>
<input id="title" type="text" />

// Button states
<Button disabled={isLoading} aria-busy={isLoading}>
  {isLoading ? 'Salvando...' : 'Salvar'}
</Button>

// Focus management
const inputRef = useRef<HTMLInputElement>(null)
useEffect(() => {
  inputRef.current?.focus()
}, [])
```

## Performance Optimization

### Image Optimization

```typescript
import Image from 'next/image'

<Image
  src={photo.url}
  alt={photo.alt}
  width={800}
  height={600}
  className="object-cover"
  placeholder="blur"
  blurDataURL={photo.blurHash}
  loading="lazy"
/>
```

### Code Splitting

```typescript
// Dynamic imports for large components
import dynamic from 'next/dynamic'

const PhotoVideoManager = dynamic(
  () => import('@/components/PhotoVideoManager'),
  {
    loading: () => <Skeleton />,
    ssr: false, // Don't render on server (uses browser APIs)
  }
)
```

### Memoization

```typescript
import { useMemo, useCallback } from 'react'

// Expensive computation
const sortedProperties = useMemo(() => {
  return properties.sort((a, b) => b.price - a.price)
}, [properties])

// Callback stability
const handleClick = useCallback(() => {
  console.log('Clicked')
}, [])
```

## Testing Guidelines

### Component Tests (Vitest + Testing Library)

```typescript
import { render, screen } from '@testing-library/react'
import { describe, it, expect } from 'vitest'
import PropertyCard from './PropertyCard'

describe('PropertyCard', () => {
  it('renders property title and price', () => {
    const property = {
      id: '1',
      title: 'Casa com 3 quartos',
      price: 500000,
    }

    render(<PropertyCard property={property} />)

    expect(screen.getByText('Casa com 3 quartos')).toBeInTheDocument()
    expect(screen.getByText('R$ 500.000')).toBeInTheDocument()
  })
})
```

## Common Patterns

### Custom Hooks

```typescript
// hooks/useMediaQuery.ts
import { useState, useEffect } from 'react'

export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false)

  useEffect(() => {
    const media = window.matchMedia(query)
    setMatches(media.matches)

    const listener = (e: MediaQueryListEvent) => setMatches(e.matches)
    media.addEventListener('change', listener)

    return () => media.removeEventListener('change', listener)
  }, [query])

  return matches
}

// Usage
const isMobile = useMediaQuery('(max-width: 768px)')
```

### Context Providers

```typescript
'use client'

import { createContext, useContext, useState, ReactNode } from 'react'

interface TenantContextValue {
  tenantId: string
  setTenantId: (id: string) => void
}

const TenantContext = createContext<TenantContextValue | undefined>(undefined)

export function TenantProvider({ children }: { children: ReactNode }) {
  const [tenantId, setTenantId] = useState('')

  return (
    <TenantContext.Provider value={{ tenantId, setTenantId }}>
      {children}
    </TenantContext.Provider>
  )
}

export function useTenant() {
  const context = useContext(TenantContext)
  if (!context) {
    throw new Error('useTenant must be used within TenantProvider')
  }
  return context
}
```

## Response Guidelines

- Provide complete, production-ready code
- Use TypeScript with strict type safety
- Follow Next.js 14+ App Router conventions
- Prefer Server Components, use Client Components only when necessary
- Include error handling and loading states
- Write accessible, semantic HTML
- Use shadcn/ui components for consistent UI
- Optimize for performance (Image, dynamic imports)
- Document complex logic with comments

## Remember

- **Server Components by default** - Only add `'use client'` when needed
- **Type everything** - No `any` types
- **Validate at boundaries** - Use Zod for form/API validation
- **Cache wisely** - Use React Query for client state, Next.js cache for server
- **Optimize images** - Always use `next/image`
- **Accessibility matters** - Use semantic HTML, ARIA labels, keyboard navigation
- **Test components** - Write tests for critical UI logic
